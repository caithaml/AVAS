**********************
Windows PowerShell transcript start
Start time: 20171020091522
Username: DESKTOP-SOQV869\Lukas
RunAs User: DESKTOP-SOQV869\Lukas
Configuration Name: 
Machine: DESKTOP-SOQV869 (Microsoft Windows NT 10.0.16299.0)
Host Application: C:\WINDOWS\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe
Process ID: 10760
PSVersion: 5.1.16299.19
PSEdition: Desktop
PSCompatibleVersions: 1.0, 2.0, 3.0, 4.0, 5.0, 5.1.16299.19
BuildVersion: 10.0.16299.19
CLRVersion: 4.0.30319.42000
WSManStackVersion: 3.0
PSRemotingProtocolVersion: 2.3
SerializationVersion: 1.1.0.1
**********************
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-09-15-22.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty



Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-09-46-27.txt
10/20/2017 09:46:27 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-09-46-32.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty



PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

Start-PoshWebGUI
Listening for request


RequestTraceIdentifier : 00000000-0000-0000-0200-0080010000ff
AcceptTypes            :
ContentEncoding        : System.Text.SBCSCodePageEncoding
ContentLength64        : 0
ContentType            :
Headers                : {Connection, Host}
HttpMethod             : GET
InputStream            : System.IO.Stream+NullStream
IsAuthenticated        : False
IsLocal                : True
IsSecureConnection     : False
IsWebSocketRequest     : False
QueryString            : {}
RawUrl                 : /
ServiceName            :
Url                    : http://localhost:8000/
UrlReferrer            :
UserAgent              :
UserHostAddress        : [::1]:8000
UserHostName           : localhost:8000
UserLanguages          :
ClientCertificateError :
TransportContext       : System.Net.HttpListenerRequestContext
Cookies                : {}
ProtocolVersion        : 1.1
HasEntityBody          : False
KeepAlive              : True
RemoteEndPoint         : [::1]:52895
LocalEndPoint          : [::1]:8000

Sending response of The expression after '.' in a pipeline element produced an object that was not valid. It must result in a command name, a script block, or a CommandInfo object.
ContentEncoding   :
ContentType       :
OutputStream      :
RedirectLocation  :
StatusCode        : 200
StatusDescription : OK
Cookies           : {}
SendChunked       : False
KeepAlive         : True
Headers           : {Content-Length}
ContentLength64   : 160
ProtocolVersion   : 1.1

Listening for request
RequestTraceIdentifier : 00000000-0000-0000-0200-0080000000ff
AcceptTypes            : {*/*}
ContentEncoding        : System.Text.SBCSCodePageEncoding
ContentLength64        : 0
ContentType            :
Headers                : {UA-CPU, Connection, Accept, Accept-Encoding...}
HttpMethod             : GET
InputStream            : System.IO.Stream+NullStream
IsAuthenticated        : False
IsLocal                : True
IsSecureConnection     : False
IsWebSocketRequest     : False
QueryString            : {}
RawUrl                 : /
ServiceName            :
Url                    : http://localhost:8000/
UrlReferrer            :
UserAgent              : Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; Win64; x64; Trident/7.0; .NET4.0C; .NET4.0E)
UserHostAddress        : [::1]:8000
UserHostName           : localhost:8000
UserLanguages          : {en-GB, en-US;q=0.8, en;q=0.5, cs;q=0.3}
ClientCertificateError :
TransportContext       : System.Net.HttpListenerRequestContext
Cookies                : {}
ProtocolVersion        : 1.1
HasEntityBody          : False
KeepAlive              : True
RemoteEndPoint         : [::1]:52896
LocalEndPoint          : [::1]:8000

Sending response of The expression after '.' in a pipeline element produced an object that was not valid. It must result in a command name, a script block, or a CommandInfo object.
ContentEncoding   :
ContentType       :
OutputStream      :
RedirectLocation  :
StatusCode        : 200
StatusDescription : OK
Cookies           : {}
SendChunked       : False
KeepAlive         : True
Headers           : {Content-Length}
ContentLength64   : 160
ProtocolVersion   : 1.1

Listening for request


PS C:\WINDOWS\system32> Function Start-PoshWebGUI ($ScriptBlock)
{
    # We create a scriptblock that waits for the server to launch and then opens a web browser control
    $UserWindow = {
            
            # Wait-ServerLaunch will continually repeatedly attempt to get a response from the URL before continuing
            function Wait-ServerLaunch
            {

                try {
                    $url="http://localhost:8000/"
                    $Test = New-Object System.Net.WebClient
                    $Test.DownloadString($url);
                }
                catch
                { start-sleep -Seconds 1; Wait-ServerLaunch }
 
            }

            Wait-ServerLaunch
            [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
            [xml]$XAML = @'
            <Window
                xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                Title="PowerShell HTML GUI" WindowStartupLocation="CenterScreen">

                    <WebBrowser Name="WebBrowser"></WebBrowser>

            </Window>
'@

            #Read XAML
            $reader=(New-Object System.Xml.XmlNodeReader $xaml) 
            $Form=[Windows.Markup.XamlReader]::Load( $reader )
            #===========================================================================
            # Store Form Objects In PowerShell
            #===========================================================================
            $WebBrowser = $Form.FindName("WebBrowser")

            $WebBrowser.Navigate("http://localhost:8000/")

            $Form.ShowDialog()
            Start-Sleep -Seconds 1

            # Once the end user closes out of the browser we send the kill url to tell the server to shut down.
            $url="http://localhost:8000/kill"
            (New-Object System.Net.WebClient).DownloadString($url);
    }
 
    $RunspacePool = [RunspaceFactory]::CreateRunspacePool()
    $RunspacePool.ApartmentState = "STA"
    $RunspacePool.Open()
    $Jobs = @()
 

       $Job = [powershell]::Create().AddScript($UserWindow).AddArgument($_)
       $Job.RunspacePool = $RunspacePool
       $Jobs += New-Object PSObject -Property @{
          RunNum = $_
          Pipe = $Job
          Result = $Job.BeginInvoke()
       }


    # Create HttpListener Object
    $SimpleServer = New-Object Net.HttpListener

    # Tell the HttpListener what port to listen on
    #    As long as we use localhost we don't need admin rights. To listen on externally accessible IP addresses we will need admin rights
    $SimpleServer.Prefixes.Add("http://localhost:8000/")

    # Start up the server
    $SimpleServer.Start()

    while($SimpleServer.IsListening)
    {
        Write-Host "Listening for request"
        # Tell the server to wait for a request to come in on that port.
        $Context = $SimpleServer.GetContext()

        #Once a request has been captured the details of the request and the template for the response are created in our $context variable
        Write-Verbose "Context has been captured"

        # $Context.Request contains details about the request
        # $Context.Response is basically a template of what can be sent back to the browser
        # $Context.User contains information about the user who sent the request. This is useful in situations where authentication is necessary


        # Sometimes the browser will request the favicon.ico which we don't care about. We just drop that request and go to the next one.
        if($Context.Request.Url.LocalPath -eq "/favicon.ico")
        {
            do
            {

                    $Context.Response.Close()
                    $Context = $SimpleServer.GetContext()

            }while($Context.Request.Url.LocalPath -eq "/favicon.ico")
        }

        # Creating a friendly way to shutdown the server
        if($Context.Request.Url.LocalPath -eq "/kill")
        {

                    $Context.Response.Close()
                    $SimpleServer.Stop()
                    break

        }
    
        $Context.Request
        # Handling different URLs

        $result = try {.$ScriptBlock} catch {$_.Exception.Message}

        if($result -ne $null) {
            if($result -is [string]){
                
                Write-Verbose "A [string] object was returned. Writing it directly to the response stream."

            } else {

                Write-Verbose "Converting PS Objects into JSON objects"
                $result = $result | ConvertTo-Json
                
            }
        }

        Write-Host "Sending response of $Result"

        # We convert the result to bytes from ASCII encoded text
        $buffer = [System.Text.Encoding]::ASCII.GetBytes($Result)

        # We need to let the browser know how many bytes we are going to be sending
        $context.Response.ContentLength64 = $buffer.Length

        # We send the response back to the browser
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)

        # We close the response to let the browser know we are done sending the response
        $Context.Response.Close()

        $Context.Response
    }

}

Start-PoshWebGUI
Listening for request


RequestTraceIdentifier : 00000000-0000-0000-0200-0080010000fd
AcceptTypes            :
ContentEncoding        : System.Text.SBCSCodePageEncoding
ContentLength64        : 0
ContentType            :
Headers                : {Host}
HttpMethod             : GET
InputStream            : System.IO.Stream+NullStream
IsAuthenticated        : False
IsLocal                : True
IsSecureConnection     : False
IsWebSocketRequest     : False
QueryString            : {}
RawUrl                 : /
ServiceName            :
Url                    : http://localhost:8000/
UrlReferrer            :
UserAgent              :
UserHostAddress        : [::1]:8000
UserHostName           : localhost:8000
UserLanguages          :
ClientCertificateError :
TransportContext       : System.Net.HttpListenerRequestContext
Cookies                : {}
ProtocolVersion        : 1.1
HasEntityBody          : False
KeepAlive              : True
RemoteEndPoint         : [::1]:52897
LocalEndPoint          : [::1]:8000

Sending response of The expression after '.' in a pipeline element produced an object that was not valid. It must result in a command name, a script block, or a CommandInfo object.
ContentEncoding   :
ContentType       :
OutputStream      :
RedirectLocation  :
StatusCode        : 200
StatusDescription : OK
Cookies           : {}
SendChunked       : False
KeepAlive         : True
Headers           : {Content-Length}
ContentLength64   : 160
ProtocolVersion   : 1.1

Listening for request
RequestTraceIdentifier : 00000000-0000-0000-0200-0080010000fc
AcceptTypes            : {*/*}
ContentEncoding        : System.Text.SBCSCodePageEncoding
ContentLength64        : 0
ContentType            :
Headers                : {UA-CPU, Connection, Accept, Accept-Encoding...}
HttpMethod             : GET
InputStream            : System.IO.Stream+NullStream
IsAuthenticated        : False
IsLocal                : True
IsSecureConnection     : False
IsWebSocketRequest     : False
QueryString            : {}
RawUrl                 : /
ServiceName            :
Url                    : http://localhost:8000/
UrlReferrer            :
UserAgent              : Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; Win64; x64; Trident/7.0; .NET4.0C; .NET4.0E)
UserHostAddress        : [::1]:8000
UserHostName           : localhost:8000
UserLanguages          : {en-GB, en-US;q=0.8, en;q=0.5, cs;q=0.3}
ClientCertificateError :
TransportContext       : System.Net.HttpListenerRequestContext
Cookies                : {}
ProtocolVersion        : 1.1
HasEntityBody          : False
KeepAlive              : True
RemoteEndPoint         : [::1]:52898
LocalEndPoint          : [::1]:8000

Sending response of The expression after '.' in a pipeline element produced an object that was not valid. It must result in a command name, a script block, or a CommandInfo object.
ContentEncoding   :
ContentType       :
OutputStream      :
RedirectLocation  :
StatusCode        : 200
StatusDescription : OK
Cookies           : {}
SendChunked       : False
KeepAlive         : True
Headers           : {Content-Length}
ContentLength64   : 160
ProtocolVersion   : 1.1

Listening for request


PS C:\WINDOWS\system32> D:\SICZ\AVAS\formular.ps1
At D:\SICZ\AVAS\formular.ps1:769 char:1
+ {
+ ~
Missing closing '}' in statement block or type definition.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : MissingEndCurlyBrace

Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-19-31.txt
10/20/2017 10:19:31 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-19-37.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty



Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-20-27.txt
10/20/2017 10:20:27 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-20-33.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


PS C:\WINDOWS\system32> D:\SICZ\AVAS\formular.ps1
At D:\SICZ\AVAS\formular.ps1:864 char:30
+         $mjmenouzivatele.Text$json.User
+                              ~~~~~
Unexpected token '$json' in expression or statement.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : UnexpectedToken

Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-22-41.txt
10/20/2017 10:22:41 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-22-45.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-28-33.txt
10/20/2017 10:28:33 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-28-37.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-29-02.txt
10/20/2017 10:29:02 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-29-06.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-29-39.txt
10/20/2017 10:29:39 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-29-44.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-32-18.txt
10/20/2017 10:32:18 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-32-24.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-32-55.txt
10/20/2017 10:32:55 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-33-01.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-34-01.txt
10/20/2017 10:34:01 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-34-08.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-38-12.txt
10/20/2017 10:38:12 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-38-18.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


Transcript started, output file is D:\SICZ\AVAS\AVAS_2017_10_20.log
Transcript started, output file is ./transcript2017-10-20-10-45-02.txt
10/20/2017 10:45:02 - Nacitani json konfiguracniho souboru
Transcript started, output file is D:\SICZ\AVAS/debug-2017-10-20-10-45-07.log
-message pokracuji ve zpracovani
spoustim test app diff

spoustim test services diff
spoustim test scheduled tasks diff
spoustim test hotfix diff
DisplayName                                  DisplayVersion Publisher
-----------                                  -------------- ---------
VMware Player                                12.5.7         VMware, Inc.
Microsoft Visual Studio Code                 1.17.0         Microsoft Corporation
Offline Files
Device Association Service
File History Service
IKE and AuthIP IPsec Keying Modules
Windows Image Acquisition (WIA)
Storage Service
Touch Keyboard and Handwriting Panel Service
Windows Event Collector
Windows Defender Antivirus Service





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































pridavam hash noteproperty

Cancel


